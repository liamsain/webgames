<html>

<head>
  <style>
    canvas {
      width: 800;
      height: 600;
      /* border-radius: 4px; */
      /* border: 1px solid rgb(204, 204, 204); */
    }

    p {
      margin: 4px;
    }
  </style>
</head>

<body>
  <div style="display: flex;justify-content: center;">
    <canvas id="game"></canvas>
    <div>
      <p>Wall: 1/w</p>
      <p>Floor: 2/f</p>
      <p>Empty: 3/*</p>
      <p>Player: 4/p</p>
      <p>Crate: 5/c</p>
      <p>Target: 6/t</p>
      <p>Log lvl: L</p>
      <p><strong>Current: </strong></p>
      <p id="current">Wall</p>

    </div>
  </div>
  <script>

    const CellWidth = 40;
    const GridDims = { height: 20, width: 20 };
    const MapKeys = {
      Wall: '-',
      Floor: '.',
      Empty: '*',
      Player: 'p',
      Crate: 'c',
      Target: '+',
    }
    let mouseIsDown = false;

    let lastTime = 0;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = GridDims.width * dpr * CellWidth;
    canvas.style.height = GridDims.height * dpr * CellWidth;
    canvas.width = GridDims.width * dpr * CellWidth;
    canvas.height = GridDims.height * dpr * CellWidth;

    let selectedBrush = MapKeys.Wall;
    let theLevelArrays = [];
    for (let y = 0; y < GridDims.height; y++) {
      theLevelArrays.push([])
      for (let x = 0; x < GridDims.width; x++) {
        theLevelArrays[y].push('*');
      }
    }

    function drawLevel(mapArrays, ctx) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          const tile = mapArrays[y][x];
          ctx.beginPath();
          ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
          if (tile == MapKeys.Wall) {
            // ctx.fillStyle = '#c70e0e';
            ctx.fillStyle = '#f06c57';
          } else if (tile == MapKeys.Floor) {
            ctx.fillStyle = '#f9edd8';
            // ctx.fillStyle = '#c4c4c4';
          } else if (tile == MapKeys.Player) {
            ctx.fillStyle = '#1153ed';
          } else if (tile == MapKeys.Crate) {
            ctx.fillStyle = '#dce625';
          } else if (tile == MapKeys.Target) {
            ctx.fillStyle = '#25e632';
          } else if (tile == MapKeys.Empty) {
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#d1d1d1';
            ctx.stroke();
          }
          ctx.fill();
        }
      }
    }
    function handleLevelShift(arrowKey) {
      if (arrowKey == 'ArrowDown') {
        theLevelArrays.pop();
        theLevelArrays.unshift(new Array(GridDims.width).fill(MapKeys.Empty));
      } else if (arrowKey == 'ArrowUp') {
        theLevelArrays.shift();
        theLevelArrays.push(new Array(GridDims.width).fill(MapKeys.Empty));
      } else if (arrowKey == 'ArrowRight') {
        for (let y = 0; y < theLevelArrays.length; y++) {
          theLevelArrays[y].pop();
          theLevelArrays[y].unshift(MapKeys.Empty);
        }
      } else if (arrowKey == 'ArrowLeft') {
        for (let y = 0; y < theLevelArrays.length; y++) {
          theLevelArrays[y].shift();
          theLevelArrays[y].push(MapKeys.Empty);
        }
      }
    }


    function handleKeydown(key) {
      if (key == '1' || key == 'w') {
        selectedBrush = MapKeys.Wall
      } else if (key == '2' || key == 'f') {
        selectedBrush = MapKeys.Floor
      } else if (key == '3' || key == '*') {
        selectedBrush = MapKeys.Empty;
      } else if (key == '4' || key == 'p') {
        selectedBrush = MapKeys.Player;
      } else if (key == '5' || key == 'c') {
        selectedBrush = MapKeys.Crate;
      } else if (key == '6' || key == 't') {
        selectedBrush = MapKeys.Target;
      } else if (key == 'l') {
        logLevelStringToConsole();
      }
      else if (key.startsWith('Arrow')) {
        handleLevelShift(key);
      }
      for (const k in MapKeys) {
        if (selectedBrush == MapKeys[k]) {
          document.querySelector('#current').innerHTML = k;
        }
      }
    }

    async function logLevelStringToConsole() {
      let str = '';
      theLevelArrays.forEach(arr => str += `${arr.join('')}\n`)
      const type = "text/plain";
      const clipboardItemData = {
        [type]: str,
      };
      const clipboardItem = new ClipboardItem(clipboardItemData);
      await navigator.clipboard.write([clipboardItem]);
      console.log(str);
    }

    function handleMouseDown(ev) {
      const x = Math.floor(ev.offsetX / CellWidth);
      const y = Math.floor(ev.offsetY / CellWidth);
      theLevelArrays[y][x] = selectedBrush;
    }

    document.addEventListener('keydown', (ev) => {
      handleKeydown(ev.key);
    })
    document.addEventListener('mousedown', (ev) => {
      handleMouseDown(ev);
      mouseIsDown = true;
    })

    document.addEventListener('mouseup', (ev) => {
      mouseIsDown = false;
    });
    document.addEventListener('mousemove', (ev) => {
      if (mouseIsDown) {
        handleMouseDown(ev)
      }
    })
    document.addEventListener('wheel', (ev) => {
      const keys = [];
      for (const k in MapKeys) {
        keys.push(k);
      }
      debugger;
      const current = keys.findIndex(k => MapKeys[k] == selectedBrush);
      let direction = ev.deltaY > 0 ? 1 : -1;
      let key;
      if (direction == 1) {
        key = keys[(current + 1) % keys.length];
      } else {
        key = keys[(current - 1 + keys.length) % keys.length];
      }
      selectedBrush = MapKeys[key];
      document.querySelector('#current').innerHTML = key;
    })

    function update() { }
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawLevel(theLevelArrays, ctx);
    }

    function gameLoop(timestamp) {
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;
      update(delta);
      draw();

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

  </script>
</body>

</html>