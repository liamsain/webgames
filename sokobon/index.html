<html>

<head>
  <style>
    canvas {
      width: 800;
      height: 600;
      border-radius: 4px;
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <div style="display: flex;justify-content: center;">
    <canvas id="game"></canvas>
  </div>
  <script>
    function getRand(min = 0, max = 100) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function randomColour() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r}, ${g}, ${b})`;
    }

    const CellWidth = 40;
    const GridDims = { height: 20, width: 20 };
    let lastTime = 0;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = GridDims.width * dpr * CellWidth;
    canvas.style.height = GridDims.height * dpr * CellWidth;
    canvas.width = GridDims.width * dpr * CellWidth;
    canvas.height = GridDims.height * dpr * CellWidth;

    ctx.scale(dpr, dpr);
    ctx.imageSmoothingEnabled = false;

    const GameStates = {
      Playing: 'Playing',
      Over: 'Over'
    }
    let GameState = GameStates.Playing;

    const Directions = {
      R: 'R',
      D: 'D',
      L: 'L',
      U: 'U'
    };

    const MapKeys = {
      Player: 'P',
      Wall: '-',
      Crate: '#',
      Target: '+',
      Floor: '.'
    }
    const Levels = [
      {
        data: `
------
-..P.-
-.#..-
-....-
-..+.-
------
`
      }
    ];
    let currentLevel = 0;

    function convertMapLevelDataToArrays(level) {
      const mapData = Levels[level].data;
      const result = [];
      const lines = mapData.split('\n').filter(l => l.length > 0);
      for (let y = 0; y < lines.length; y++) {
        result.push([]);
        for (let x = 0; x < lines[y].length; x++) {
          result[y].push(lines[y][x]);
        }
      }
      return result;
    }

    let currentMap = convertMapLevelDataToArrays(0);

    function drawLevel(mapArrays, ctx) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          const tile = mapArrays[y][x];
          ctx.beginPath();
          if (tile == MapKeys.Wall) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#c70e0e';
          } else if (tile == MapKeys.Floor) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#c4c4c4';
          } else if (tile == MapKeys.Player) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#1153ed';
          } else if (tile == MapKeys.Crate) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#dce625';
          } else if (tile == MapKeys.Target) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#25e632';
          }
          ctx.fill();
        }
      }
    }

    function getPlayerCoord(mapArrays) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          if (mapArrays[y][x] == MapKeys.Player) {
            return {
              x, y,
            }
          }
        }
      }
    }

    function handleMove(startCoord, targetCoord) {
      const targetTile = currentMap[targetCoord.y][targetCoord.x];
      if (targetTile == MapKeys.Floor) {
        currentMap[targetCoord.y][targetCoord.x] = MapKeys.Player;
        currentMap[startCoord.y][startCoord.x] = MapKeys.Floor;
      } else if (targetTile == MapKeys.Crate) {
        let crateDestCoord = {...targetCoord}; // which tile is the player trying to push the crate onto?
        if (targetCoord.x > startCoord.x) {
          // direction = Directions.R;
          crateDestCoord.x += 1;
        } else if (targetCoord.x < startCoord.x) {
          // direction = Directions.L;
          crateDestCoord.x -= 1;
        } else if (targetCoord.y > startCoord.y) {
          // direction = Directions.D;
          crateDestCoord.y += 1;
        } else {
          // direction = Directions.U;
          crateDestCoord.y -= 1;
        }
        if (currentMap[crateDestCoord.y][crateDestCoord.x] == MapKeys.Floor) {
          currentMap[crateDestCoord.y][crateDestCoord.x] = MapKeys.Crate;
          currentMap[targetCoord.y][targetCoord.x] = MapKeys.Player;
          currentMap[startCoord.y][startCoord.x] = MapKeys.Floor;
        }
      } 

    }

    function handleKeydown(key) {
      const { x, y } = getPlayerCoord(currentMap);
      if (key == 'd' || key == 'ArrowRight') {
        handleMove({ x, y }, { x: x + 1, y })
      } else if (key == 'a' || key == 'ArrowLeft') {
        handleMove({ x, y }, { x: x - 1, y })
      } else if (key == 'w' || key == 'ArrowUp') {
        handleMove({ x, y }, { x, y: y - 1 })
      } else if (key == 's' || key == 'ArrowDown') {
        handleMove({ x, y }, { x, y: y + 1 })
      }
    }

    document.addEventListener('keydown', (ev) => {
      handleKeydown(ev.key);
    })

    function update() { }

    function gameLoop(timestamp) {
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;
      update(delta);
      drawLevel(currentMap, ctx);
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

  </script>
</body>

</html>