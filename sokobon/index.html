<html>

<head>
  <style>
    canvas {
      width: 800;
      height: 600;
      /* border-radius: 4px; */
      /*border: 1px solid rgb(204, 204, 204);*/
    }

    button {
      margin: 12px;
      padding: 12px;
    }

    h2 {
      text-align: center;
      margin: 0;
    }
  </style>
</head>

<body>

  <h2 id="levelName">Title</h2>
  <div style="display: flex;justify-content: center;">
    <canvas id="game"></canvas>
  </div>
  <div style="display: flex;justify-content: center;">
    <button onclick="reset();">Reset</button>
    <button onclick="undo()">Undo</button>
  </div>

  <script>

    let CellWidth = 40;
    const GridDims = { height: 20, width: 20 };
    let lastTime = 0;
    let states = [];
    let currentLevel = 0;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = GridDims.width * dpr * CellWidth;
    canvas.style.height = GridDims.height * dpr * CellWidth;
    canvas.width = GridDims.width * dpr * CellWidth;
    canvas.height = GridDims.height * dpr * CellWidth;


    const MapKeys = {
      Player: 'p',
      Wall: '-',
      Crate: 'c',
      Target: '+',
      Floor: '.',
      Empty: '*'
    }
    const Levels = [
      {
        name: 'Parrot',
        extras: ['make a parrot'],
        data: `
        ********************
********************
********************
********************
*******------*******
*******-....-*******
*******-..c.-*******
*******-..p.-*******
*******-..---*******
*******-...-********
*******-..+-********
*******-----********
********************
********************
********************
********************
********************
********************
********************
********************
          `
      },
      {
        name: 'Alien',
        extras: ['make alien cry'],
        data: `
        ********************
********************
********************
*******-------******
*******-.-..+-******
*******-....--******
*******-.....-******
*******--.--.-******
*******-.....-******
*******-.....-******
*******----.--******
*******----.--******
*******-.....--*****
*******-.c....-*****
*******-.p....-*****
*******--------*****
********************
********************
********************
********************
        `
      },
      {
        name: 'Smoking man',
        data: `********************
********************
********************
**********---*******
******---------*****
*****--.....-*******
*****--.--.---*-****
*****--.....----****-
******---...+-******-
********--.----*****
***-------.--.---***
***--.....c.....-***
****--....p....--***
*****----.....--****
********-------*****
*************--*****
********************
********************
********************
********************
`
      },

      {
        name: 'Sausage dog',
        data: `
        ********************
********************
********************
********************
********************
**-**********-----**
**----*******-...-**
**-+----------.-.-**
**-pc............-**
**-..--------..---**
**----******----****
********************
********************
********************
********************
********************
********************
********************
********************
********************

        `
      },
      {
        name: 'Chick',
        data: `********************
********************
********************
********************
*********------*****
********--....-*****
*******--....--*****
*****---....-.--****
*****-..-.-..cp-****
****--+--.-...--****
***---.--..-.--*****
***---.....----*****
****--..--..--******
*****--------*******
********************
********************
********************
********************
********************
********************
`
      },
      {
        name: 'Ghostface',
        data: `********************
********************
********************
*****-------********
****---....--*******
*****--.....-*******
******--.-..--******
*******-.-...--*****
*******-.-.-..--****
*******-...-..--****
*******-.......-****
*******-..-....-****
*******-......--****
*******-...----*****
*******-c-.-********
*******-p.+-********
*******-----********
*******----*********
********---*********
*********-**********
`
      },

      {
        name: 'Sideburns',
        data: `
        ********************
********************
********************
********************
***---------------**
***----........---**
***-.............-**
***-....--.......-**
***-.....-.--....-**
***-+---.-..-....-**
***-.p.c.-..-....-**
***--.......------**
***---.........---**
***----.......----**
***---------------**
********************
********************
********************
********************
********************
        `
      },

      {
        name: 'Hair and Glasses',
        data: `********************
*****-------********
***---.-...---******
***-..pc.....--*****
***-.--.......--****
***-.---.......---**
***-.---.........-**
***-..........--+-**
***-.-----------.-**
***-.-*********-.-**
**--.-*******---.--*
**--.-******--....-*
*--..--****--....--*
*-....-****-.....-**
*-..-.------..-..-**
*-...............-**
*--...------....--**
**-----****--..--***
************----****
********************
`
      },
      {
        name: 'Crooked Staff', data: `
********************
*****----***********
*-----..-*****---***
*-pc....----**-.-***
*-.---.....-*--.--**
*-.-.-.....-*-...--*
*-.-.-----.-*-.+..--
*-.........-*-...--*-
*-.----.--.----..-**
*-.-..-.....-*-.--**
*-.-..-.....-*-.--**
*-....---..----..--*
--......----......--
-................---
-...-.----....-..-**
--..-.--*--......-**
*-..-.--**--.....-**
*-------***-------**
********************
********************

      `},

    ];


    document.querySelector('#levelName').innerHTML = Levels[currentLevel].name;

    function convertMapLevelDataToArrays(level) {
      const mapData = Levels[level].data;
      const result = [];
      const lines = mapData.split('\n').filter(l => l.length > 0).map(l => l.trim());
      for (let y = 0; y < lines.length; y++) {
        result.push([]);
        for (let x = 0; x < lines[y].length; x++) {
          result[y].push(lines[y][x]);
        }
      }
      return result;
    }

    let currentMap = convertMapLevelDataToArrays(0);
    states = [structuredClone(currentMap)];

    function drawLevel(mapArrays, ctx) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          const tile = mapArrays[y][x];
          ctx.beginPath();
          if (tile == MapKeys.Wall) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#f06c57';
          } else if (tile == MapKeys.Floor) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#f9edd8';
          } else if (tile == MapKeys.Player) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#1153ed';
          } else if (tile == MapKeys.Crate) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#dce625';
          } else if (tile == MapKeys.Target) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#929930';
          } else if (tile == MapKeys.Empty) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#fff';
          }
          ctx.fill();
        }
      }
    }

    function getPlayerCoord(mapArrays) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          if (mapArrays[y][x] == MapKeys.Player) {
            return {
              x, y,
            }
          }
        }
      }
    }
    function goNextLevel() {
      currentLevel += 1;
      if (currentLevel > Levels.length - 1) {
        currentLevel = 0;
      }
      currentMap = convertMapLevelDataToArrays(currentLevel);
      states = [structuredClone(currentMap)];
      document.querySelector('#levelName').innerHTML = Levels[currentLevel].name;
    }

    function handleMove(startCoord, targetCoord) {
      const targetTile = currentMap[targetCoord.y][targetCoord.x];
      if (targetTile == MapKeys.Floor) {
        currentMap[targetCoord.y][targetCoord.x] = MapKeys.Player;
        currentMap[startCoord.y][startCoord.x] = MapKeys.Floor;
      } else if (targetTile == MapKeys.Crate) {
        let crateDestCoord = { ...targetCoord }; // which tile is the player trying to push the crate onto?
        if (targetCoord.x > startCoord.x) {
          // right
          crateDestCoord.x += 1;
        } else if (targetCoord.x < startCoord.x) {
          // left
          crateDestCoord.x -= 1;
        } else if (targetCoord.y > startCoord.y) {
          // down
          crateDestCoord.y += 1;
        } else {
          // up
          crateDestCoord.y -= 1;
        }
        const crateDestTile = currentMap[crateDestCoord.y][crateDestCoord.x]
        if (crateDestTile == MapKeys.Floor || crateDestTile == MapKeys.Target) {
          currentMap[crateDestCoord.y][crateDestCoord.x] = MapKeys.Crate;
          currentMap[targetCoord.y][targetCoord.x] = MapKeys.Player;
          currentMap[startCoord.y][startCoord.x] = MapKeys.Floor;
          if (crateDestTile == MapKeys.Target) {
            goNextLevel();
            return;
          }
        }
      }
      states.push(structuredClone(currentMap));
    }

    function undo() {
      states.pop();
      if (states.length) {
        currentMap = states.pop();
      }
      states.push(structuredClone(currentMap));
    }
    function reset() {
      currentMap = convertMapLevelDataToArrays(currentLevel)
      states = [structuredClone(currentMap)];
    }
    function handleKeydown(key) {
      const { x, y } = getPlayerCoord(currentMap);
      if (key == 'd' || key == 'ArrowRight') {
        handleMove({ x, y }, { x: x + 1, y })
      } else if (key == 'a' || key == 'ArrowLeft') {
        handleMove({ x, y }, { x: x - 1, y })
      } else if (key == 'w' || key == 'ArrowUp') {
        handleMove({ x, y }, { x, y: y - 1 })
      } else if (key == 's' || key == 'ArrowDown') {
        handleMove({ x, y }, { x, y: y + 1 })
      } else if (key == 'r') {
        reset();
      } else if (key == 'z') {
        undo();
      }
    }
    function handleDeviceWidth() {
      if (window.innerWidth < 800) {
        CellWidth = 25;
        canvas.style.width = GridDims.width * dpr * CellWidth;
        canvas.style.height = GridDims.height * dpr * CellWidth;
        canvas.width = GridDims.width * dpr * CellWidth;
        canvas.height = GridDims.height * dpr * CellWidth;
      } else {
        CellWidth = 40;
        canvas.style.height = GridDims.height * dpr * CellWidth;
        canvas.style.width = GridDims.width * dpr * CellWidth;
        canvas.width = GridDims.width * dpr * CellWidth;
        canvas.height = GridDims.height * dpr * CellWidth;
      }
    }
    handleDeviceWidth();

    document.addEventListener('keydown', (ev) => {
      handleKeydown(ev.key);
    })
    window.addEventListener('resize', (ev) => {
      handleDeviceWidth();
    });

    function update() { }
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawLevel(currentMap, ctx);
    }

    function gameLoop(timestamp) {
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;
      update(delta);
      draw();

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

  </script>
</body>

</html>