<html>

<head>
  <style>
    canvas {
      width: 800;
      height: 600;
      /* border-radius: 4px; */
      border: 1px solid rgb(204, 204, 204);
    }
  </style>
</head>

<body>
  <div style="display: flex;justify-content: center;">
    <canvas id="game"></canvas>
  </div>
  <script>

    const CellWidth = 40;
    const GridDims = { height: 20, width: 20 };
    let lastTime = 0;
    let states = [];
    let currentLevel = 0;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = GridDims.width * dpr * CellWidth;
    canvas.style.height = GridDims.height * dpr * CellWidth;
    canvas.width = GridDims.width * dpr * CellWidth;
    canvas.height = GridDims.height * dpr * CellWidth;


    const MapKeys = {
      Player: 'p',
      Wall: '-',
      Crate: 'c',
      Target: '+',
      Floor: '.',
      Empty: '*'
    }
    const Levels = [
      {
        name: 'chicken',
        data: `********************
********************
********************
********************
*********------*****
********--....-*****
*******--....--*****
*****---....-.--****
*****-..-.-..cp-****
****--+--.-...--****
***---.--..-.--*****
***---.....----*****
****--..--..--******
*****--------*******
********************
********************
********************
********************
********************
********************
`
      },
      {
        name: 'ghostface',
        data: `********************
********************
********************
*****-------********
****---....--*******
*****--.....-*******
******--.-..--******
*******-.-...--*****
*******-.-.-..--****
*******-...-..--****
*******-.......-****
*******-..-....-****
*******-......--****
*******-...----*****
*******-c-.-********
*******-p.+-********
*******-----********
*******----*********
********---*********
*********-**********
`
      },
      {
        name: 'sausage dog',
        data: `
        -**********-----
        ----*******-...-
        -+----------.-.-
        -pc............-
        -..--------..---
        ----******----
        `
      },
      {
        name: 'sideburns',
        data: `
        ---------------
        ----........---
        -.............-
        -....--.......-
        -.....-.--....-
        -+---.-..-....-
        -.p.c.-..-....-
        --.......------
        ---.........---
        ----.......----
        ---------------
        `
      },
      {
        name: 'p',
        extras: ['make a parrot'],
        data: `
          ------
          -....-
          -..c.-
          -..p.-
          -..---
          -...-
          -..+-
          -----
          `
      },
      {
        name: 'alien',
        extras: ['make alien cry'],
        data: `
        -------
        -.-..+-
        -....--
        -.....-
        --.--.-
        -.....-
        -.....-
        ----.--
        ----.--
        -.....--
        -.c....-
        -.p....-
        --------
        `
      },

    ];

    function convertMapLevelDataToArrays(level) {
      const mapData = Levels[level].data;
      const result = [];
      const lines = mapData.split('\n').filter(l => l.length > 0).map(l => l.trim());
      for (let y = 0; y < lines.length; y++) {
        result.push([]);
        for (let x = 0; x < lines[y].length; x++) {
          result[y].push(lines[y][x]);
        }
      }
      return result;
    }

    let currentMap = convertMapLevelDataToArrays(0);
    states = [structuredClone(currentMap)];

    function drawLevel(mapArrays, ctx) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          const tile = mapArrays[y][x];
          ctx.beginPath();
          if (tile == MapKeys.Wall) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#c70e0e';
          } else if (tile == MapKeys.Floor) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#c4c4c4';
          } else if (tile == MapKeys.Player) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#1153ed';
          } else if (tile == MapKeys.Crate) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#dce625';
          } else if (tile == MapKeys.Target) {
            ctx.rect(x * CellWidth, y * CellWidth, CellWidth, CellWidth);
            ctx.fillStyle = '#25e632';
          }
          ctx.fill();
        }
      }
    }

    function getPlayerCoord(mapArrays) {
      for (let y = 0; y < mapArrays.length; y++) {
        for (let x = 0; x < mapArrays[y].length; x++) {
          if (mapArrays[y][x] == MapKeys.Player) {
            return {
              x, y,
            }
          }
        }
      }
    }

    function handleMove(startCoord, targetCoord) {
      const targetTile = currentMap[targetCoord.y][targetCoord.x];
      if (targetTile == MapKeys.Floor) {
        currentMap[targetCoord.y][targetCoord.x] = MapKeys.Player;
        currentMap[startCoord.y][startCoord.x] = MapKeys.Floor;
      } else if (targetTile == MapKeys.Crate) {
        let crateDestCoord = { ...targetCoord }; // which tile is the player trying to push the crate onto?
        if (targetCoord.x > startCoord.x) {
          // right
          crateDestCoord.x += 1;
        } else if (targetCoord.x < startCoord.x) {
          // left
          crateDestCoord.x -= 1;
        } else if (targetCoord.y > startCoord.y) {
          // down
          crateDestCoord.y += 1;
        } else {
          // up
          crateDestCoord.y -= 1;
        }
        const crateDestTile = currentMap[crateDestCoord.y][crateDestCoord.x]
        if (crateDestTile == MapKeys.Floor || crateDestTile == MapKeys.Target) {
          currentMap[crateDestCoord.y][crateDestCoord.x] = MapKeys.Crate;
          currentMap[targetCoord.y][targetCoord.x] = MapKeys.Player;
          currentMap[startCoord.y][startCoord.x] = MapKeys.Floor;
          if (crateDestTile == MapKeys.Target) {
            currentLevel += 1;
            if (currentLevel > Levels.length - 1) {
              currentLevel = 0;
            }
            currentMap = convertMapLevelDataToArrays(currentLevel);
            states = [structuredClone(currentMap)];
            return;
          }
        }
      }
      states.push(structuredClone(currentMap));
    }

    function handleKeydown(key) {
      const { x, y } = getPlayerCoord(currentMap);
      if (key == 'd' || key == 'ArrowRight') {
        handleMove({ x, y }, { x: x + 1, y })
      } else if (key == 'a' || key == 'ArrowLeft') {
        handleMove({ x, y }, { x: x - 1, y })
      } else if (key == 'w' || key == 'ArrowUp') {
        handleMove({ x, y }, { x, y: y - 1 })
      } else if (key == 's' || key == 'ArrowDown') {
        handleMove({ x, y }, { x, y: y + 1 })
      } else if (key == 'r') {
        currentMap = convertMapLevelDataToArrays(currentLevel)
        states = [structuredClone(currentMap)];
      } else if (key == 'z') {
        states.pop();
        if (states.length) {
          currentMap = states.pop();
        }
        states.push(structuredClone(currentMap));
      }
    }

    document.addEventListener('keydown', (ev) => {
      handleKeydown(ev.key);
    })

    function update() { }
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawLevel(currentMap, ctx);
    }

    function gameLoop(timestamp) {
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;
      update(delta);
      draw();

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

  </script>
</body>

</html>