<html>

<head>
  <style>
    canvas {
      width: 800;
      height: 600;
      border-radius: 4px;
      border: 1px solid #9be655;
    }

    /* body {
      background-color: black;
    } */
  </style>
</head>

<body>
  <div style="display: flex;justify-content: center;">
    <canvas id="game"></canvas>
  </div>
  <script>
    function getRand(min = 0, max = 100) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function randomColour() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r}, ${g}, ${b})`;
    }
    const GameStates = {
      Playing: 'Playing',
      Over: 'Over'
    }
    let GameState = GameStates.Playing;

    const Directions = {
      R: 'R',
      D: 'D',
      L: 'L',
      U: 'U'
    };
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const width = 600;
    const height = 600;
    const CellWidth = 20;

    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.imageSmoothingEnabled = false;
    let lastTime = 0;




    class Snake {
      parts = [];
      headPos = { x: 20, y: 20 };
      direction = Directions.R;
      ctx = null;
      partSize = 10;
      length = 10;
      colour = randomColour();
      appleCoord = { x: 0, y: 0 };
      maxX = 0;
      maxY = 0;
      coordHashMap = {};
      lastDirection = Directions.R;
      unusedGridCells = [];
      constructor(arg) {
        if (arg) {
          for (const k in arg) {
            this[k] = arg[k]
          }
        }
        this.lastDirection = this.direction;
        const headX = this.headPos.x;
        const headY = this.headPos.y;
        this.parts.push({ x: headX, y: headY });
        for (let i = 1; i < this.length; i++) {
          if (this.direction === Directions.R) {
            this.parts.push({ x: headX - i, y: headY })
          } else if (this.direction === Directions.D) {
            this.parts.push({ x: headX, y: headY - i })
          } else if (this.direction === Directions.L) {
            this.parts.push({ x: headX + i, y: headY })
          } else {
            this.parts.push({ x: headX, y: headY + i })
          }
        }

        for (let y = 0; y < this.maxY; y++) {
          for (let x = 0; x < this.maxX; x++) {
            if (!this.parts.includes(part => part.x === x && part.y === y)) {
              this.unusedGridCells.push({ x, y });
            }
          }
        }
      }
      draw() {
        for (let i = 0; i < this.parts.length; i++) {
          const part = this.parts[i];
          this.ctx.beginPath();
          this.ctx.rect(part.x * this.partSize, part.y * this.partSize, this.partSize, this.partSize);
          this.ctx.fillStyle = this.colour;
          this.ctx.fill();
        }
        this.ctx.beginPath();
        this.ctx.rect(this.appleCoord.x * this.partSize, this.appleCoord.y * this.partSize, this.partSize, this.partSize);
        this.ctx.fillStyle = 'red';
        this.ctx.fill();
      }
      handleKeyPress(key) {

        if (key == 'd' || key == 'ArrowRight') {
          if (this.lastDirection == Directions.D || this.lastDirection == Directions.U) {
            this.direction = Directions.R;
          }
        } else if (key == 'a' || key == 'ArrowLeft') {
          if (this.lastDirection == Directions.D || this.lastDirection == Directions.U) {
            this.direction = Directions.L;
          }
        } else if (key == 'w' || key == 'ArrowUp') {
          if (this.lastDirection == Directions.L || this.lastDirection == Directions.R) {
            this.direction = Directions.U;
          }
        } else if (key == 's' || key == 'ArrowDown') {
          if (this.lastDirection == Directions.L || this.lastDirection == Directions.R) {
            this.direction = Directions.D;
          }
        }

      }
      update() {
        const head = this.parts[0];
        let nextCoord = { x: 0, y: 0 };
        if (this.direction === Directions.R) {
          nextCoord = { x: head.x + 1, y: head.y }
        } else if (this.direction === Directions.D) {
          nextCoord = { x: head.x, y: head.y + 1 }
        } else if (this.direction === Directions.L) {
          nextCoord = { x: head.x - 1, y: head.y }
        } else {
          nextCoord = { x: head.x, y: head.y - 1 }
        }
        this.lastDirection = this.direction;
        if (nextCoord.x >= width / this.partSize) {
          nextCoord.x = 0;
        } else if (nextCoord.x < 0) {
          nextCoord.x = width / this.partSize;
        } else if (nextCoord.y >= height / this.partSize) {
          nextCoord.y = 0;
        } else if (nextCoord.y < 0) {
          nextCoord.y = height / this.partSize
        }
        let appleEaten = false;
        if (this.parts.slice(1).some(part => part.x === nextCoord.x && part.y === nextCoord.y)) {
          GameState = GameStates.Over;
          return;
        }
        if (nextCoord.x == this.appleCoord.x && nextCoord.y == this.appleCoord.y) {
          appleEaten = true;
        }
        const cellIsNewHeadPos = cell => cell.x == nextCoord.x && cell.y == nextCoord.y;
        this.unusedGridCells = this.unusedGridCells.filter(cell => !cellIsNewHeadPos(cell));

        for (let i = 0; i < this.parts.length; i++) {
          const tmp = { x: this.parts[i].x, y: this.parts[i].y }
          this.parts[i].x = nextCoord.x;
          this.parts[i].y = nextCoord.y;
          nextCoord = tmp;
        }
        // apple eaten check
        if (appleEaten) {
          this.parts.push({ x: this.appleCoord.x, y: this.appleCoord.y });
          this.appleCoord = { x: getRand(0, 19), y: getRand(0, 19) }
        } else {
          // push the cell that the tail just exited
          this.unusedGridCells.push({ ...nextCoord });
        }


      }
      addTailPart() {
        const currentTail = this.parts[this.parts.length - 1];
        const newTail = { x: currentTail.x, y: currentTail.y };

        this.parts.push(newTail)
      }
    }
    const MaxX = width / CellWidth;
    const MaxY = height / CellWidth;

    const appleCoord = { x: getRand(0, 19), y: getRand(0, 19) }
    let snake = new Snake({
      ctx,
      colour: 'green',
      partSize: width / CellWidth,
      maxX: MaxX,
      maxY: MaxY,
      appleCoord,
    });
    addEventListener('keydown', (e) => {
      snake.handleKeyPress(e.key);
    })


    setInterval(() => {
      if (GameState == GameStates.Playing) {
        snake.update();
      } else {
        snake = new Snake({
          ctx,
          colour: 'green',
          partSize: width / CellWidth,
          maxX: MaxX,
          maxY: MaxY,
          appleCoord,
        });
        GameState = GameStates.Playing;
      }
    }, 100)
    function update(delta) {
    }
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#9be655";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      snake.draw();
    }

    function gameLoop(timestamp) {
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;
      update(delta);
      draw();
      window.requestAnimationFrame(gameLoop);
    }
    window.requestAnimationFrame(gameLoop);
  </script>
</body>

</html>