<html>

<head>
  <style>
    canvas {
      width: 800;
      height: 600;
      border-radius: 4px;
      border: 1px solid #9be655;
    }

    /* body {
      background-color: black;
    } */
  </style>
</head>

<body>
  <div style="display: flex;justify-content: center;">
    <canvas id="game"></canvas>
  </div>
  <script>
    function getRand(min = 0, max = 100) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function randomColour() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r}, ${g}, ${b})`;
    }

    const Directions = {
      R: 'R',
      D: 'D',
      L: 'L',
      U: 'U'
    };
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const width = 600;
    const height = 600;
    const CellWidth = 20;

    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.imageSmoothingEnabled = false;
    let lastTime = 0;


    let direction = Directions.R;
    addEventListener('keydown', (e) => {
      if (e.key == 'd' || e.key == 'ArrowRight') {
        if (direction == Directions.D || direction == Directions.U) {
          direction = Directions.R;
        }
      } else if (e.key == 'a' || e.key == 'ArrowLeft') {
        if (direction == Directions.D || direction == Directions.U) {
          direction = Directions.L;
        }
      } else if (e.key == 'w' || e.key == 'ArrowUp') {
        if (direction == Directions.L || direction == Directions.R) {
          direction = Directions.U;
        }
      } else if (e.key == 's' || e.key == 'ArrowDown') {
        if (direction == Directions.L || direction == Directions.R) {
          direction = Directions.D;
        }
      }
    })


    class Grid {
      width = 20;
      height = 20;
      cellSize = 4;
      showLines = false;
      lineColour = 'red';
      ctx = null;
      constructor(arg) {
        for (const k in arg) {
          this[k] = arg[k];
        }
      }
      draw() {
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            this.ctx.beginPath();
            const x = j * this.cellSize;
            const y = i * this.cellSize;
            this.ctx.strokeRect(x, y, this.cellSize, this.cellSize);
            this.ctx.strokeStyle = 'blue'
            this.ctx.stroke();
          }
        }
      }
    }

    class Snake {
      parts = [];
      headPos = { x: 20, y: 20 };
      direction = Directions.R;
      ctx = null;
      partSize = 10;
      length = 10;
      colour = randomColour();
      appleCoord = { x: 0, y: 0 };
      maxX = 0;
      maxY = 0;
      coordHashMap = {};
      constructor(arg) {
        if (arg) {
          for (const k in arg) {
            this[k] = arg[k]
          }
        }
        const headX = this.headPos.x;
        const headY = this.headPos.y;
        this.parts.push({ x: headX, y: headY });
        for (let i = 1; i < this.length; i++) {
          if (this.direction === Directions.R) {
            this.parts.push({ x: headX - i, y: headY })
          } else if (this.direction === Directions.D) {
            this.parts.push({ x: headX, y: headY - i })
          } else if (this.direction === Directions.L) {
            this.parts.push({ x: headX + i, y: headY })
          } else {
            this.parts.push({ x: headX, y: headY + i })
          }
        }

        for (let y = 0; y < this.maxY; y++) {
          for (let x = 0; x < this.maxX; x++) {
            this.coordHashMap[`${x} ${y}`] = false;
          }
        }
      }
      draw() {
        for (let i = 0; i < this.parts.length; i++) {
          const part = this.parts[i];
          this.ctx.beginPath();
          this.ctx.rect(part.x * this.partSize, part.y * this.partSize, this.partSize, this.partSize);
          this.ctx.fillStyle = this.colour;
          this.ctx.fill();
        }
        this.ctx.beginPath();
        this.ctx.rect(this.appleCoord.x * this.partSize, this.appleCoord.y * this.partSize, this.partSize, this.partSize);
        this.ctx.fillStyle = 'red';
        this.ctx.fill();
      }
      update() {
        this.direction = direction;
        const head = this.parts[0];
        let nextCoord = { x: 0, y: 0 };
        if (this.direction === Directions.R) {
          nextCoord = { x: head.x + 1, y: head.y }
        } else if (this.direction === Directions.D) {
          nextCoord = { x: head.x, y: head.y + 1 }
        } else if (this.direction === Directions.L) {
          nextCoord = { x: head.x - 1, y: head.y }
        } else {
          nextCoord = { x: head.x, y: head.y - 1 }
        }
        if (nextCoord.x >= width / this.partSize) {
          nextCoord.x = 0;
        } else if (nextCoord.x < 0) {
          nextCoord.x = width / this.partSize;
        } else if (nextCoord.y >= height / this.partSize) {
          nextCoord.y = 0;
        } else if (nextCoord.y < 0) {
          nextCoord.y = height / this.partSize
        }
        let appleEaten = false;
        if (nextCoord.x == this.appleCoord.x && nextCoord.y == this.appleCoord.y) {
          console.log('apple eaten')
          appleEaten = true;
        }

        for (let i = 0; i < this.parts.length; i++) {
          const tmp = { x: this.parts[i].x, y: this.parts[i].y }
          this.parts[i].x = nextCoord.x;
          this.parts[i].y = nextCoord.y;
          nextCoord = tmp;
        }
        if (appleEaten) {
          this.parts.push({ x: this.appleCoord.x, y: this.appleCoord.y });
          this.appleCoord = { x: getRand(0, 19), y: getRand(0, 19) }
        }
      }
      addTailPart() {
        const currentTail = this.parts[this.parts.length - 1];
        const newTail = { x: currentTail.x, y: currentTail.y };

        this.parts.push(newTail)
      }
    }
    const MaxX = width / CellWidth;
    const MaxY = height / CellWidth;

    const appleCoord = { x: getRand(0, 19), y: getRand(0, 19) }
    const snake = new Snake({
      ctx,
      colour: 'green',
      partSize: width / CellWidth,
      maxX: MaxX,
      maxY: MaxY,
      appleCoord,
    });

    setInterval(() => { snake.update(); }, 100)
    function update(delta) {
    }
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#9be655";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      snake.draw();
    }

    function gameLoop(timestamp) {
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;
      update(delta);
      draw();
      window.requestAnimationFrame(gameLoop);
    }
    window.requestAnimationFrame(gameLoop);
  </script>
</body>

</html>